## Introduction
LIBERO provides over 100 task examples, an intuitive teleoperation interface, and a clear, easy-to-follow task‐generation pipeline. However, its modular design and encapsulated logic make it essential to explore the source code yourself once you begin annotating.

Before you start, we recommend reviewing these key scripts and modules:

#### Task (BDDL file) generation and validation:
- `scripts/create_libero_task_example.py`
  - This file is an example to (1) define a scene in the scene class (2) define the task (3) generate bddl file for the task, which represents all necessary information of the task and will be used to set up the task.
- `scripts/collect_demonstration.py`
  - This file is used to teleoperate the robot to complete tasks. It is especially useful when you finish your task design and want to double-check the correctness of your reward code. We provide instructions in the later part.

#### Benchmark scene setup:
This file lists all scenes available in Libero. Each scene is defined as one separate class.
- `libero/libero/benchmark/mu_creation.py`

Predicate definition & Object-state specifications:
- `libero/libero/envs/base_predicates.py`
- `libero/libero/envs/__init__.py`
- `libero/libero/envs/object_states/base_object_states.py`

When designing tasks, feel free to use your imagination to extend or modify the code to achieve the desired effect, as long as the overall structure remains intact!

## Workflow Overview
1. Check the scene
   - First, consult the documentation to review the scene associated with your task. 
   - For a deeper dive, examine the implementation in `mu_creation.py` (You may design your own scenes afterwards!).
2. Implement the reward function
   - We have provided a reward design reference generated by AI in our sheet. This is just for reference and may be useless sometimes. Double-check and design carefully by yourself!
   - (If needed) Reference predefined object states in `base_object_states.py`.
   - (If needed) Define any custom predicates in `base_predicates.py` (and its `__init__.py`). Aim for reusable predicates, but one-offs are fine.
3. Generate the BDDL task file
   - Run your adapted `create_libero_task_example.py` to generate a BDDL task file under `/tmp/bddl/your-bddl-flie.bddl`.
4. Validate via teleoperation
   - Run collect_demonstration.py to ensure your task works as intended. You may try to use the following format:
   ```bash
   /path-to-your-collect_demonstration.py --bddl-file "/tmp/bddl/your-bddl-flie.bddl" --device keyboard --robots Panda
   ```
> **Note:** We provide a automated script to help you generate the BDDL file and validate your task via teleoperation. You can find it in `scripts/auto_tun.py`. This script will automatically generate the BDDL file and start the teleoperation process for you. You can run it with the following command:

```bash
python scripts/auto_run.py <path-to-your-task-file.py>
```

## A Concrete Example

Given a task: ``[living_room_scene_1] turn the basket upside down over the alphabet soup``

1. Check and familiarize yourself with the scene

   ![](images/living_room_scene_1.png)

   In the main function of ``scripts/create_libero_task_example.py``, specify ``scene_name`` as ``living_room_scene_1``, ``language`` as the task description ``turn the basket upside down over the alphabet soup``.

2. Start to write reward function

   The success of a task is checked in the variable ``goal_states`` through “predicates”. For example, in ``create_libero_task_example.py``, the first has the following goal_states:

   ```python
   goal_states = [
       ("Open", "wooden_cabinet_1_top_region"),
       ("In", "akita_black_bowl_1", "wooden_cabinet_1_bottom_region"),
   ]
   ```

   Each condition will be evaluated by the corresponding predicate function defined in ``base_predicate.py``. For example, the function ``Open`` is like this:

   ```python
   Class Open(UnaryAtomic):
       def __call__(self, arg):
           return arg.is_open()
   ```

   The ``arg`` here is ``wooden_cabinet_1_top_region``, which is defined as a region object in LIBERO. Each object has its corresponding object state, defined in ``base_object_states.py``. Also, each object has a few predefined functions that help you get the necessary information about objects. These functions can be called in predicate functions to define a high-level predicate, and finally used in ``goal_states``.

   Let's delve deeper into the ``is_open()`` function:

   ```python
   def is_open(self):
   	for joint in self.env.get_object(self.object_name).joints:
           qpos_addr = self.env.sim.model.get_joint_qpos_addr(joint)
           qpos = self.env.sim.data.qpos[qpos_addr]
           if self.env.get_object(self.object_name).is_open(qpos)
               return True
      return False
   ```

   We can see that  it actually uses another ``is_open`` defined in ``libero/envs/objects/articulated_objects.py``.

   ```python
   @register_object
   class WoodenCabinet(ArticulatedObject):
       def __init__(
           self,
           name="wooden_cabinet",
           obj_name="wooden_cabinet",
           joints=[dict(type="free", damping="0.0005")],
       ):
           super().__init__(name, obj_name, joints)
           self.object_properties["articulation"]["default_open_ranges"] = [-0.16, -0.14]
           self.object_properties["articulation"]["default_close_ranges"] = [0.0, 0.005]
   
       def is_open(self, qpos):
           if qpos < max(self.object_properties["articulation"]["default_open_ranges"]):
               return True
           else:
               return False
   
       def is_close(self, qpos):
           if qpos > min(self.object_properties["articulation"]["default_close_ranges"]):
               return True
           else:
               return False
   ```

   If you browse the `objects/` directory, you'll see that each object has its own customized functions. For example, the cabinet defines its own implementations of `is_open` and `is_close`. It's also worth noting that the properties used in these definitions—such as `default_close_ranges`—are further specified in the object's source file (an XML file). For instance, the `WoodenCabinet` has its definitions in `libero/assets/articulated_objects/wooden_cabinet.xml`.

   ```xml
   	      <body name="cabinet_top" pos="0 0.0 0">
                   <inertial pos="0 0 0" mass="3" diaginertia="1 1 1" />
                   <joint name="top_level" type="slide" pos="0 0 0" axis="0 1 0"
   		       limited="true" range="-0.16 0.01" damping="50"/>
   
   ```

   In this case, the file defines the range of the top drawer, which we used in the `is_open` function mentioned earlier. There are many other examples as well—be sure to explore different objects to better inform the design of your task.

   To define your task, you'll need to:

   1. Think about the desired goal state for your task.
   2. Identify or define a predicate that represents this goal state (if one doesn't already exist).
   3. Implement your predicate using the accessible properties and existing functions of the relevant objects.

   Continue on with our example: how to decide whether a basket covers the alphabet soup? Browse ``base_predicates.py`` and find that there aren’t any predefined predicates to ensure that. We may need to define a custom predicate ourselves. 

   Note that “A covers B” means 1. A is upside down, 2. B is contained in A. Since condition 2) can be checked by using the predicate ``In``, we only need to define a predicate to check whether an object is ``UpsideDown``.

   ```python
   # This is the most creative part!
   class UpsideDown(UnaryAtomic):
       def __call__(self, arg):
           geom = arg.get_geom_state()
           w, x, y, z = geom["quat"]
           quat_for_rs = np.array([x, y, z, w])
          	
           R = transform_utils.quat2mat(quat_for_rs)
           z_axis_world = R[:, 2]
           return z_axis_world[2] < 0
       def expected_arg_types(self):
           return [BaseObjectState]
   ```

   Make sure you add the new predicate into ``VALIDATE_PREDICATE_FN_DICT ``in ``predicates/__init__.py``

   Register the task by passing ``language``, ``scene_name``, ``objects_of_interests`` and ``goal_states`` into the function ``register_task_info``.

   ```python
       scene_name = "living_room_scene1"
       language = "turn the basket upside down over the alphabet soup"
       register_task_info(
           language,
           scene_name=scene_name,
           objects_of_interest=["alphabet_soup_1", "basket_1"],
           goal_states=[
               ("In", "alphabet_soup_1", "basket_1_contain_region"),
               ("UpsideDown", "basket_1")
           ]
       )
   
       bddl_file_names, failures = generate_bddl_from_task_info()
       print(bddl_file_names)
   ```

3. Generate the BDDL task file

   Simply run ``create_libero_task_example.py`` and your task will appear in ``/tmp/bddl/your-bddl-flie.bddl``. (If you are a Windows user, make sure ``/tmp`` is created beforehand)

   ```shell
   $ python LIBERO/scripts/create_libero_task_example.py
   Successfully generated: 1
   ['/tmp/pddl/LIVING_ROOM_SCENE1_turn_the_basket_upside_down_over_the_alphabet_soup.bddl']
   ```

4. Validate via teleoperation

   We also provided instructions for teleoperation in the readme file in our repo.

   Run ``collect_demonstration.py`` to start teleoperation for your task, and 

   - Guide the robot to complete your task.
   - Verify the reward: When a task completes successfully, the current teleoperation window will automatically close and, shortly thereafter, a new one will open. The third number in the console shows how many times you’ve succeeded in the current session.
   - Be careful to avoid **reward hacking**, test on any edge cases you can come up with!

   => (teleoperate)

   ![](images/teleoperation.png)

   => The third number indicates the number of successes in the current session

   ```shell
   DataCollectionWrapper: making folder at demonstration_data/tmp/libero_living_room_tabletop_manipulation_Ln_turn_the_basket_upside_down_over_the_alphabet_soup/...
   3181
   ['193648263_472938\\ep_37489_872893']
   1 <= pay attention to this number
   ```

   Record the video of you successfully finishing the task via teleoperation and you are ready to submit your implementation!

## Miscellaneous Tips
(Keep updating this section as you explore more so that others can benefit from your experience!)
- **World coordinate system**: In libero, the world coordinate system is defined as follows:
  - The x-axis points towards yourself.
  - The y-axis points to RHS.
  - The z-axis points up.
  
  Here is a visual representation of the coordinate system:
    ![](images/world_coordinate.jpg)
- **Positioning**: sometimes you might find it hard to know the exact target position. For example you want to check whether an object is put on the corner of the table but you cannot know the exact position of the corner. In this case, you can print out the current position and target position (there is one in function `PositionWithin` in `base_predicates.py`). However, it is strongly advised to try to calculate the position by yourself through initial state (defined in the scene class, you can know it in the function `define_regions` most of the time) and the size of the object (defined in the xml file of the object) and double-check the position by printing it out.

### Debugging
We provide a debug printing function in `libero/libero/envs/debug.py`. You can use it to print out the current state of the environment, which can be helpful for debugging your task. If you want to use it, simply set the environment variable `LIBERO_DEBUG` to `true` before running your script. For example:

```bash
export LIBERO_DEBUG=true
python scripts/auto_run.py <path-to-your-task-file.py>
```
in windows, you can use the following command:

```bash
set LIBERO_DEBUG=true
python scripts/auto_run.py <path-to-your-task-file.py>
```

### Long Path Issue
If you encounter a "long path" issue on Windows, you can try the following steps:
1. Open the Registry Editor by typing `regedit` in the Windows search bar.
2. Navigate to `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem`.
3. Find the `LongPathsEnabled` key and set its value to `1`.
4. Restart your computer for the changes to take effect.

### Robot Components

#### Available Robot Components

The following robot components are automatically registered and available for use in predicates:

- `gripper0_finger1` - First gripper finger
- `gripper0_finger2` - Second gripper finger
- `gripper0_finger1_pad` - First gripper finger pad
- `gripper0_finger2_pad` - Second gripper finger pad
- `gripper0_hand` - Gripper hand/palm

#### Usage in Predicates

You can use these gripper components directly in contact-based predicates and position-based predicates.
For example:

```python
# Check if gripper finger is touching an object
goal_states = [
    ("InContact", "gripper0_finger1", "cube_1"),
    ("InContact", "gripper0_finger2", "sphere_1"),
    ("Above", "gripper0_hand", "cube_1"),
]
```

#### Implementation Details

The robot components are implemented as `RobotObjectState` objects that:
- Track the geometric state of robot collision geometries
- Support contact detection with other objects in the environment
- Are automatically initialized when the environment is set up
- Can be accessed through the standard `get_object()` interface

### Constraints

Constraints are wrapper predicates that allow you to specify temporal requirements for predicates during task execution. They monitor whether a predicate condition holds throughout the entire episode, occurs at least once, or never occurs.

#### Available Constraint Types

##### ConstraintAlways
Ensures that a predicate remains true throughout the entire task execution. The constraint fails if the predicate becomes false at any point during the episode.

**Use Case**: Maintaining object orientation, preventing spills, or ensuring continuous contact.

**Example**:
```python
("ConstraintAlways", ("UpRight", "akita_black_bowl_1"))
```
This ensures the bowl remains upright throughout the entire task execution.

##### ConstraintOnce
Requires that a predicate becomes true at least once during the task execution. The constraint is satisfied as soon as the predicate evaluates to true for the first time.

**Use Case**: Ensuring specific interactions occur, like grasping an object or making contact.

**Example**:
```python
("ConstraintOnce", ("InContact", "gripper0_finger1", "akita_black_bowl_1"))
```
This ensures the gripper finger touches the bowl at least once during the task.

##### ConstraintNever
Ensures that a predicate never becomes true during the task execution. The constraint fails immediately if the predicate evaluates to true at any point.

**Use Case**: Avoiding collisions, preventing unwanted interactions, or maintaining safety conditions.

**Example**:
```python
("ConstraintNever", ("InContact", "akita_black_bowl_1", "plate_1"))
```
This ensures the bowl never touches the plate during the entire task.

#### Usage in Task Definition

Constraints can be used in both `goal_states` and as standalone requirements. Here's a comprehensive example:

```python
goal_states = [
    # Regular goal predicates
    ("In", "cube_1", "box_1"),
    ("Closed", "wooden_cabinet_1_top_region"),
    
    # Constraint predicates
    ("ConstraintAlways", ("UpRight", "akita_black_bowl_1")),
    ("ConstraintOnce", ("InContact", "gripper0_finger1", "akita_black_bowl_1")),
    ("ConstraintNever", ("InContact", "akita_black_bowl_1", "plate_1")),
]
```

### Sequential
You can define sequential tasks using the `Sequential` predicate. This allows you to specify a sequence of conditions that must be met in order, enabling more complex task structures.
```python
("Sequential", (
    ("All", (
        ("Close", "wooden_cabinet_1_middle_region"),
        ("Not", ("InContact", "akita_black_bowl_1", "plate_1")),
    )),
    ("All", (
        ("InContact", "akita_black_bowl_1", "plate_1"),
        ("ConstraintAlways", ("Upright", "akita_black_bowl_1")),
    ))
))
```
For this example, the first condition requires the cabinet to be closed and the bowl not to be in contact with the plate. Only after the first condition is satisfied, the second condition will be checked, which requires the bowl to be in contact with the plate and remain upright.

### Watch
The `Watch` predicate allows you to monitor a specific predicate condition throughout the task execution. It always returns `True` and is useful for tracking conditions without affecting task success.
```python
("Watch", ("InContact", "gripper0_finger1", "akita_black_bowl_1"))
```

### RememberState
The `RememberState` predicate allows you to store the state of an object at a initial point.
```python
("Under", "akita_black_bowl_1", ("RememberState", "gripper0_hand")),
```

## Task Dimension Diversity

### Task Design Guidelines for Object Manipulation with Rich Dimensions

This section provides a categorized list of example tasks that highlight **dimensions currently underrepresented** in our dataset. These examples are intended to inspire the design of **new tasks** that incorporate richer aspects such as **motion dynamics, object-object interactions, camera-view reasoning, and process constraints**. You may leverage the sequential predicate for process constraint in the instruction.

Please use these examples as reference to explore **new types of interactions**, rather than applying simple augmentations (e.g., changing objects or slightly adjusting angles). You are encouraged to go beyond traditional pick-and-place tasks and propose creative, meaningful manipulations that add novel dimensions to the dataset.


### Task Categories and Examples

---

### 1. Motion Types (Address the Way of Moving)

| Task Description | Example |
|------------------|---------|
| Push an object to a target location | Push the bowl on the cabinet to the right front corner |
| Push an object over | Push the milk carton over |
| Shake an object | Shake the ketchup up and down three times |
| Spin an object | Spin the tomato sauce |
| Drag along a line | Drag the white-and-yellow mug to the right of porcelain mug along a straight line |
| Push back and forth | Push the bowl on the table back and forth |
| Roll cylindrical object | Roll the tomato sauce can back and forth |
| Drop object to fall into a region | Pick up the bowl and drop it in the top drawer |
| Slide in circular motion | Slide the butter to make its center move along a circular path |

---

### 2. Camera-View Related Tasks

| Task Description | Example |
|------------------|---------|
| Fully hide from all cameras | Hide the butter such that it is invisible from all cameras |
| Hide from front but visible to top camera | Hide the butter from the front camera view while visible for the top camera |
| Reveal hidden item | Find the hidden bowl and put it on the table |
| Rotate object for top-view inspection | Rotate the milk carton to make all sides inspected for top camera |
| Use shadows in reasoning | Pick up the book and adjust its position to make its shadow cover the mug |
| Texture related | Put all dairy products in the basket

---

### 3. Non-Grabbing Interaction

| Task Description | Example |
|------------------|---------|
| Hover gripper | Hover the gripper above the basket |
| Point without touching | Point to the orange juice without touching it |
| Tap object | Tap the top of tomato sauce twice |
| Position gripper near object without grabbing | Put the gripper to the place where it needs to be in order to pick the milk carton from side, but do not grab it |

---

### 4. Object-Object Interaction

| Task Description | Example |
|------------------|---------|
| Use one object to move another | Use the alphabet soup to push tomato sauce to the right of butter, the gripper should not touch tomato sauce |
| Push an object over with another object | Pick the butter and use it to push the milk carton over |
| Use object to close something | Use the can to close the drawer |
| Use object as separator | Use the wooden tray upright as a separator between tomato sauce and alphabet soup |
| Align parts accurately | Align two books corner to corner |

---

### 5. Process Constraints

| Task Description | Example |
|------------------|---------|
| Swap positions without lifting | Swap the position of butter and cream cheese without lifting either |
| Pick–flip–return in place | Pick the ketchup, flip it over and back, then put it back in place |
| Pick specific part | Pick the ketchup at its bottle neck |
| Touch in sequence | Touch the front of the basket, then the back, then return to front again |
| Push through narrow gap | Push the tomato sauce between the gap between milk carton and orange juice |
| Let object reset after tilt | Tilt the orange juice by pushing it, then let it go and allow it to return to its original state |

---

### 6. Initial State Variations

| Task Description | Example |
|------------------|---------|
| Re-orient upright | Rotate the Moka pot from lying flat back to upright |
| Retrieve from enclosed space | Get the bowl out of the drawer and put it on the table |
| Remove from stacked position | Remove the butter from the top of cream cheese |
| Dump contents | Tilt the wooden tray to dump its contents on the table |
| Break linear arrangement | Make the center of butter, tomato sauce and milk no longer on a straight line |

---

